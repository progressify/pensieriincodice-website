---
authors: [Valerio Galano]
title: "Speciale - Imparare a programmare [community edition] (con Sirio Negri e Alex Raccuglia)"
layout: episode
episode_type: full
series: []
categories: [podcast]
tags: [community,programmazione,software,sviluppo]
seasons: 2
number: 80
date: Sun, 26 Dec 2021 03:00:02 +0000
audio: "episodes/PIC80.mp3"
audio_duration: 1758
audio_size: 28115004
transcript: transcripts/srt/PIC80.srt
url: /episodes/80
aliases: 
  - /80
image: "images/covers/PIC80.png"
explicit: "no"
draft: false
type: podcast
---
L'episodio in cui davamo consigli su come iniziare a programmare ha suscitato varie reazioni nel gruppo Telegram di Pensieri in codice. In questo episodio speciale, ascoltiamo due interessanti contributi da parte di Alex Raccuglia e Sirio Negri.<br /><br />I link dell'episodio di oggi: <br />Ep.69 - Imparare a programmare (con Alessandro, Eugenio e Luca del PointerPodcast) - <a href="https://www.spreaker.com/episode/47890146" rel="noopener">https://www.spreaker.com/episode/47890146</a> <br /><br />Pensieri in codice si sostiene grazie alle tue condivisioni, ai tuoi contributi e alla tua partecipazione. Scopri di più su <a href="https://pensieriincodice.it/" rel="noopener">https://pensieriincodice.it/</a> <br />---<br /><br />Affiliazioni:<br />ProtonVPN - <a href="https://go.getproton.me" rel="noopener">https://go.getproton.me</a>/SHN0 <br />ProtonMail - <a href="https://go.getproton.me/SHMB" rel="noopener">https://go.getproton.me/SHMB</a> <br />Todoist - <a href="https://doist.grsm.io/valeriogalano5066" rel="noopener">https://doist.grsm.io/valeriogalano5066</a> <br />Satispay - <a href="https://bit.ly/3fQUVaU" rel="noopener">https://bit.ly/3fQUVaU</a> <br />Amazon - <a href="https://amzn.to/3CPOWgC" rel="noopener">https://amzn.to/3CPOWgC</a> <br /><br />Attrezzatura:<br />Shure Microfono Podcast USB MV7 - <a href="https://amzn.to/3862ZRf" rel="noopener">https://amzn.to/3862ZRf</a> <br />Neewer NW-5 Pannello fonoassorbente - <a href="https://amzn.to/3rysTFP" rel="noopener">https://amzn.to/3rysTFP</a> <br /><br />Utilizzando i link affiliati, il costo di un qualsiasi acquisto non sarà maggiore per te, ma una piccola parte del ricavato servirà per sostenere il progetto.<br /><br />

{{< credits season="season2" >}}

<!-- more -->

## Testo dell'episodio

Ero sicuro che l'episodio di due settimane fa, in cui parlavamo di come approcciarsi
al mondo della programmazione, avrebbe infiammato gli animi.
I programmatori sono pur sempre umani, o almeno questo è quello che diciamo in giro, e abbiamo
le nostre preferenze, le nostre simpatie, le nostre antipatie.
E per questo motivo l'uscita di un episodio in cui si consigliava un approccio piuttosto
che un altro, un linguaggio piuttosto che un altro, ha scatenato non poche discussioni
sul gruppo Telegram di Pensieri in Codice, che ormai è il luogo di incontro della nostra
community.
Quindi ho pensato di chiedere a chi ne avesse voglia di inviare la propria opinione in formato
audio, in modo da poterla riportare qui su questo podcast e farla ascoltare anche a te.
E siccome un paio di amici hanno deciso di accogliere il mio invito, quello che ne è
venuto fuori è qualcosa di davvero interessante.
Quindi, ascoltiamo la sigla e poi diamo il via a questo episodio, che intitoleremo
Imparare a Programmare Community Edition.
Benvenuti su Pensieri in Codice, il podcast dove si ragiona da informatici, con Valerio Galan.
È stato il primo consiglio in assoluto che ti ho dato nello scorso episodio.
Ricordi, se vuoi farti un'idea di da dove iniziare a programmare, ascolta più pareri
possibile.
Interpella più persone che puoi, che abbiano conoscenze e passione per l'argomento.
Ed è proprio quello che faremo oggi, ascolteremo due interessanti racconti di esperienze e
di opinioni, anche in contrasto con quello che io stesso ti ho detto nello scorso episodio.
A proposito, se non lo hai già fatto, ti consiglio di recuperare l'episodio 69, questo per conoscere
le basi da cui si dipanano i ragionamenti che stai per ascoltare.
Il primo dei due contributi di oggi arriva da Sirio Negri.
Sirio, come ascolterai dalla sua viva voce, sviluppa software per professione da anni
ed ha delle idee piuttosto chiare e precise su quali siano le prime tematiche da affrontare
in questo lavoro e quanto sia realmente difficile programmare.
Allora, scusate che faccio un vocale ma sto guidando.
Però ho fatto una riflessione sull'ultimo puntata del podcast.
Allora, è una mia, come si suol dire in un cerco tecnico, opinione scomoda.
Bold opinion, come chiamatamo il cavolo, volete?
Tutto giustissimo e appoggio la scelta di Python per iniziare.
Proprio perché nella sua semplicità leva a tanti scogli che altri linguaggi invece hanno.
Anche il PHP, io ora sono sviluppatore PHP, sì, posso dire che non è così difficile
ma per imparare proprio i concetti basilari della programmazione io non lo consiglierei.
Perché fino a farò un inform for ci arrivi.
Dopo diventa veramente un guazzapunto.
E questo è inutile dire il contrario.
Python invece parte subito in modo molto semplice.
C'è un motivo se viene usato ormai nella stragrande maggioranza dei progetti data science
perché è talmente semplice e veloce da sviluppare e anche da debuggare, da utilizzare, eccetera,
da testare che è tutto tempo guadagnato per arrivare poi ad avere il progetto di dati in mano.
Ecco, e mi ricordo ai tempi dell'università che programmavano sempre più che in Python.
Buona parte dell'elaborazione la facevamo in Python, poi semmai l'ultima parte, giusto perché le librerie
che usavamo noi di statistica e visualizzazione grafica dei dati erano in C++ o meglio si potrebbero
utilizzare anche in Python, ma l'utilizzo non era così immediato, soprattutto l'installazione
non era così immediata, per risparmiare tempo facevo, e quella parte lì la facevo ancora in C++.
Però quasi tutta l'elaborazione dei dati, almeno dal file puro ad averci dei dati tutti
a un file che sia regolato, diciamo così, in modo da essere leggibile facilmente in C++
senza smadonnare con 25.000 formati, eccetera, lo facevo in Python.
Ancora adesso sto sviluppando in Python e tante cose obiettivamente le vedo molto più semplici.
Quello che è la mia bold opinion reale è che sì, è vero che è difficile programmare, ma non è così tanto vero.
Io ho fatto, almeno per chi inizia, io ho fatto per qualche anno, ho dato lezioni di programmazione
a ragazzini dei superiori e mi sono reso conto di una cosa che non veniva proprio insegnata a programmazione
perché programmare, io gli ho sempre detto, programmare sono 4 cazzate, 10 fronzoli e 100.000 abbellimenti.
Programmare non è altro che una cosa che tu hai già in mente come fare, infatti per me programmare in un linguaggio o in un altro in realtà ha poco senso
perché programmare vuol dire una cosa che tu sai già fare, perché se no non la programmi, cioè hai già in mente come fare.
Scomporla in pezzi semplici perché il calcolatore è stupido, è fondamentalmente stupido, è più stupido di un bambino di 2 anni,
con tutto rispetto ai bambini di 2 anni, non sa nulla, sa veramente fare 4 cose, bisogna scomporre quello che io so già fare
in passaggi più semplici possibili e poi si tratta soltanto di tradurlo in un linguaggio, esattamente come io devo andare da un posto a un altro
non posso spiegarlo a un tedesco se non ci so andare prima io, devo saperci andare e poi tradurre il processo o perché penso già in tedesco perché sono capace
o perché lo penso in italiano e poi lo traduco in tedesco, tradurre questo in un linguaggio che il tedesco capisca, perché se no non capisci quello che sto dicendo.
Quindi non è del tutto vero che programmare è difficile, noi sappiamo già programmare, almeno in partenza, si tratta di imparare poi qual è la parte difficile,
le 4 cazzate le sappiamo fare perché sono gli if, il for, mettere le memorie in un posto, anche gli stessi oggetti, la stessa programmazione degli oggetti,
una volta che la spiegano in una certa maniera, a un ragazzino che a scuola non c'ha capito un cazzo, dietro a papale perché è successo, una volta che spiegano in una certa maniera,
sa programmare oggetti, ma non è perché gli ho insegnato io a programmare oggetti, perché gli ho fatto capire cosa vuol dire, che è una cosa ben diversa.
Quello che poi diventa difficile la programmazione, obiettivamente e qui non si può dare torto, sono i fronzoli più difficili, i fronzoli facili sono semplici da imparare,
e gli abbellimenti, allora se iniziamo a parlare di accesso al database, che comunque anche lì non è così difficile, di interfacce grafiche, di design, di user experience design, di accesso a librerie particolari, eccetera, allora sì, lì diventa difficile.
Pattern di programmazione, MWC, lì sì che inizia a diventare una cosa decisamente più complessa, però a uno che si dice, che vuole iniziare a programmare, a farsi i suoi scritti in python, eccetera, digli che è difficile.
Ha la sua parte vera e ha la sua parte sbagliata, per questo motivo, perché in realtà noi sappiamo, non è un caso se ci sono dei linguaggi particolarmente semplici che insegnano a programmare ai bambini, come Scratch, perché i bambini sanno già programmare, sanno già fare un'istruzione condizionale, non la chiamano istruzione condizionale, la chiamano se, allora.
Sanno già fare un while, fintanto che non arriva a destinazione devo camminare, ecco lì che abbiamo fatto la programmazione, poi, ripeto, per gli abelimenti lì inizia la difficoltà, lì viene inizialmente la difficoltà in pattern, gestione delle immagini, mille e mille cose,
però fondamentalmente se noi non sappiamo fare una cosa, possiamo conoscere tutti i linguaggi di programmazione che vogliamo, ma la cosa principale è sapere fare quella cosa e saperla scomporre, perché il grosso difficoltà che avevano questi ragazzi, a cui veniva insegnata la programmazione, come viene insegnata a scuola, che sono degli imbecilli, scusate il termine, all'università ancora sono un pochino meglio, perché prima ti insegnano pseudocodice, però anche lì, vabbè.
Ho visto i programmi e sono rimasto un po' vasito a volte, però parlo per le basi, poi quando devi parlare di pattern, di programmazione è un altro paio di balle, di design, pattern design è un altro paio di balle, fino a un certo punto anche lì, però la loro grossa difficoltà è che andavano a scuola e insegnavano,
il leaf si fa così, il for si fa così, ma non insegnavano cosa voleva dire programmare, erano tutti bloccati, una volta che capivano questo semplice concetto, che programmare vuol dire semplicemente scomporre quello che tu sai già fare, che hai già in mente come fare, spostare i dati su un file, perché quello lo sai fare, sai scrivere,
scomporlo in parti semplici e tradurlo in un linguaggio che può essere a quel punto veramente qualsiasi linguaggio di programmazione, qualsiasi linguaggio di programmazione è facile o difficile, non c'entra più assolutamente niente, niente.
Nel momento in cui capivano questa cosa, chi programmava in java, perché ho visto insegnare java alle superiori, mi sono fatto segnare la croce perché mi sembra una grandissima stonzata, non perché odi java, ma perché fondamentalmente non imparavano un cazzo, detta papale, sia che usassi cv+, sia che usassi python, sia che usassi qualsiasi altro tipo di linguaggio,
una volta capito e fatto proprio questo concetto andavano tutti come dei treni e andavano a prendere dei vuoti da chapeau, ma non perché ero bravo io, non perché insegnassi bene io, semplicemente perché gli facevo capire che cos'è la programmazione, cosa che invece non insegno.
Allora giusto per raggiungere, qualcuno può sollevare l'obiezione che io sono ormai più di vent'anni che programmo per i cazzi miei e che adesso il mio lavoro è fare programmatore, sono con tutto che amo il python, che amo i generatori statici, che mi piace andare a cercare linguaggi nuovi, al momento uso php, html, css, sass, cioè scss e queste belle tecnologie qua.
Che non amo particolarmente, soprattutto il php, però la ditta, programma in quello, ci posso fare poco o nulla.
Però a me programmazione non me l'ha insegnata solamente nessuno e anch'io ho avuto le mie difficoltà, ma ragionando sul mio percorso di apprendimento che ho avuto mi sono reso conto che la mia difficoltà non era che era difficile programmare,
era che non avevo ancora capito questo concetto, soprattutto quando sono passato alla programmazione oggetti.
Ho provato con gpp, ho provato con gpm, finché non ho trovato, paradossalmente, una guida di python, ora non mi ricordo, ma credo che in python, like programmer, like scientist, mi copio, una guida di python, che addirittura parteva dalla programmazione oggetti.
Ma non dalla programmazione oggetti, facendo la definizione di astrazione, definizione di eredità, parteva dalla programmazione oggetti, pensata come concetto, è lì che a me mi è scoccata la scintilla,
che ho capito che fondamentalmente programmare è quello che vi ho detto al messaggio prima, cioè scomporre una cosa che io so già fare in pezzi semplici, che il computer può capire, può fare, e tradurlo in un linguaggio che il computer può capire.
Ma la grossa difficoltà che nessuno mi ha insegnato, e cosa che invece quando davo ripetizioni insegnavo, era proprio il fatto che la programmazione non è difficile in sé, difficile il dopo, ma la programmazione in sé non è difficile, perché noi sappiamo già programmare.
Mi è venuto di raccontarsi il padre, perché quando facciamo una ricetta, traduciamo delle parole in movimenti, in un altro linguaggio, ed è esattamente quello, è programmare.
C'è un bel libro che ha il bimbo, che è un libro di logica, ed è fatto benissimo, ora non ho la copertina a sottomano, però secondo me va data una letta, anche come genitori.
C'è un libro di logica, e c'è scritto sopra, proprio pedotico, al coding, ma non gliene fanno prendere in mano la tastiera, perché non è prendere in mano la tastiera, programmare, e scrivere codici come l'archetipo, è quello.
Ed è lì che secondo me è l'ideale difficoltà che molti hanno. Scusate il polpettone da 9 minuti, e praticamente qua siamo appuntati ai podcast. Buona giornata.
Nonché la persona che ha curato il sound di questo podcast che stai ascoltando in questo momento. Ma quello che forse non saprai è che Alex, oltre a tutto questo, è anche un affermato sviluppatore di software, anche se soffre di un immotivato astio verso il PHP.
E quello che stai per ascoltare è il racconto dei suoi esordi e la sua visione del mondo della programmazione.
Buongiorno a tutti, io mi presento, sono Alex Raccuglia, e come secondo lavoro ho una piccola software house che sviluppa degli strumenti, dei tool, per professionisti dell'audio-video, così tanto per inquadrarla cosa.
La realtà è che sono braccia rubate all'agricoltura. Prima di tutto vorrei ringraziare Valerio per l'opportunità che ha dato a me e ad altri come me di raccontare la propria esperienza e cercherò di essere veramente molto breve.
Allora, io ho iniziato a programmare a 11 anni, nell'era degli 8-bit, con un computer che si chiamava MSX, che probabilmente nessuno di voi ha sentito nominare, ed è stato il computer più sfigato dell'era degli 8-bit, forse a pari merit con l'Amstrad, però almeno l'Amstrad c'è la grafica più bella.
E lì ho iniziato a fare le prime cose, ho passato il mio primo mese a giocare e poi ho detto vediamo di fare qualcosa e ho capito che per me programmare è essenzialmente cercare di fare ordine nell'universo perché ho una vita probabilmente disordinata e cerco di risolvere dei problemi programmando.
Altre persone probabilmente hanno risolto il tutto con la droga, con le prostitute, io l'ho fatto con l'informatica, non so se è una cosa positiva o negativa, probabilmente i posteri sapranno dirlo.
Il mio percorso poi è stato che ho fatto le scuole superiori e nelle scuole superiori ho fatto il perito informatico e dopo ho studiato ingegneria informatica e di conseguenza la mia è stata una strutturazione molto accademica, nel senso che ho studiato per fare questa cosa.
Poi mi sono ritrovato a fare altro nella vita perché ho avuto fortuna direi, molta fortuna, mi sono trovato nel posto giusto al momento giusto e ho fatto una carriera relativamente diversa da quella dell'informatica però ho sempre sviluppato piccoli strumenti personalmente per aiutare me stesso nel mio primo lavoro.
Fino al punto che 5 anni fa ho deciso di iniziare a vendere questi strumenti e mi sono scontrato con tutte le problematiche relative a tutto quello che circonda lo sviluppo di software, cioè lo sviluppo del software è una fetta molto piccola e anche abbastanza marginale di quello che significa avere una piccola software house.
Per il resto c'è molto marketing, documentazione, rapporto con i clienti, gestione dell'e-commerce, la parte di contabilità, insomma un sacco di cose che con la programmazione hanno poco a che vedere ma sono fondamentali quando si vuole avere una pur piccola attività.
Di conseguenza il mio percorso è stato prima da autodidatta nei primi 3 anni della mia vita e anche per i primi due anni della mia vita da programmatore e anche per i primi due anni del superiore dove il computer lo guardavamo col binocolo perché all'istituto tecnico tendenzialmente i primi due anni erano uguali per tutti e solo dopo ci si divideva e si prendevano delle strade ed io ho iniziato a fare informatica.
Con tutti i limiti di quella che era l'istruzione informatica negli anni 90, 80 e 90, alle superiori anni 90 all'università per cui all'università c'era soltanto come paradigma la programmazione oggetti mentre oggi sappiamo che questa è una delle tante modalità di approcciare lo sviluppo di software e anzi probabilmente non è neanche quella più in voga.
Ho fatto questo contorno, volevo dire la mia e la mia è che dipende molto da cosa vuoi fare. I ragazzi nella puntata a cui faccio i complimenti bravi ti hanno suggerito Python che io non conosco praticamente per niente e sinceramente non sono neanche interessato a conoscerlo almeno non in questa vita e hanno detto che va bene per tutte le occasioni che è una cosa positiva effettivamente.
La realtà è che credo che tu ascoltatore devi pensare se effettivamente qual è l'ambito operativo in cui tu vorresti lavorare. È ovvio che tutti vogliamo fare videogiochi quando iniziamo a programmare perché si tratta di cose belle, di cose divertenti, di cose entusiasmanti, di cose anche creative ed artistiche però credo che i videogiochi siano tra le cose più difficili da sviluppare perché devono rispondere fisicamente all'input dell'utente.
Tu giochi, ti muovi o con il mouse o con i joystick oppure anche semplicemente premendo un tasto o facendo tap sullo schermo con un mobile però dal tempo di risposta, da come questa risposta viene visualizzata, da come il mondo cambia rispetto a come tu interagisci e soprattutto da quanto tempo ci metti questo comporta un approccio fisico migliore o peggiore nei confronti del gioco per cui è una delle cose più difficili da realizzare.
È ovvio che poi dicendo così uno si tarpa le arie, la realtà è che ci sono un sacco di strumenti per cominciare a farlo senza magari essere una iena nella programmazione, ci sono un sacco di tool intermedi, non dico di guardare direttamente Unity però ci sono un sacco di strumenti di creazione di videogiochi per dirti che possono essere anche interessanti per passare inizialmente più tempo a lavorare sull'aspetto grafico e meno su quello del coding e poi man mano passarci.
Poi invece magari se uno a cui piace tantissimo l'intelligenza artificiale vuole sviluppare un modello di machine learning e allora sì, Python è probabilmente la soluzione più ideale.
Io devo essere sincero, negli ultimi 4-5 anni ho iniziato a sviluppare in Zwift per sviluppare applicazioni macOS e iOS, più Mac che iOS però mi è capitato di farle, anche farle applicazioni non soltanto indie ma anche per aziende che mi hanno chiesto dei particolari componenti nativi per iPhone e iPad.
Zwift è un linguaggio molto bello, molto pulito, molto essenziale, anche secondo me perfetto nella didattica, infatti nelle università americane lo utilizzano anche come strumento didattico.
Non sto dicendo che dovresti imparare Zwift perché poi avresti la testa aperta solo sul mondo Apple, che probabilmente non è una cosa che ti interessa.
Trovo che Zwift sia molto educativo come linguaggio, molto semplice, molto elegante, molto essenziale e ti prende per mano per certi versi.
Valerio ovviamente usa il PHP che credo che sia, non dico un crimine contro l'umanità, però nel senso che quando qualcuno l'ha creato un angelo è morto probabilmente.
E' difficile pensare a un linguaggio di programmazione così too cool, di solito si parte da cosa vuoi fare e a seconda di quello che vuoi fare ci sono linguaggi più o meno adatti.
Per dirti, se tu vuoi sviluppare un'applicazione per iOS molto semplice, molto banale o anche complessa e intricata, Zwift è la via da seguire.
Se tu vuoi lavorare in maniera molto semplice scrittando, Python è effettivamente una buona soluzione e tra l'altro ha anche un buon mercato, nel senso che il mondo ha sempre bisogno di Pythonisti, molto più di quanto ne aveva bisogno di PHPisti.
Scusate queste piccole digressioni.
Se ti interessa sviluppare e lavorare sui videogiochi allora C-Sharp probabilmente è la cosa più, CP2 e C-Sharp sono i go-to, c'è i posti dove andare a guardare.
Dico C-Sharp perché Unity che è un sistema piuttosto ricco per fare videogiochi 2D e 3D si basa su C-Sharp.
Se tu vuoi passare maggior tempo a integrare qualcosa su pagine web, su siti web allora JavaScript è dove bisogna andare e anzi forse probabilmente JavaScript è anche un po' datato e su questo altri amici potrebbero essere più d'aiuto con l'evoluzione tipo TypeScript e cose del genere.
Però qui sto dicendo cose che probabilmente non so e di conseguenza è meglio che mi stia zitto.
In realtà la domanda che hai fatto tu come ascoltatore è una domanda lecitissima, mancano secondo me delle condizioni al contorno per fare capire dove andare e come approcciarsi.
Nel senso se sei interessato un pochettino ai database, cosa che dubito perché ti appassioni i database dopo che hai iniziato a lavorare nell'informatica e non prima, allora SQL è il posto dove bisogna andare anche se poi ultimamente sul web si stanno affacciando sempre più database non relazionali per cui anche lì.
Cioè è triste che intanto che sto dando questa risposta mi rendo conto che sto facendo più domande che dando risposte che non è una cosa molto bella e molto costruttiva.
La realtà è quella di capire effettivamente dove vuoi andare a parare e poi magari scopri che quello che pensi che sia interessante per te dopo un po' diventa interessante ma meno interessante di altri ambiti operativi.
Io personalmente lavoro nell'ambito dell'audio video, dell'elaborazione dell'audio e del video, delle immagini eccetera eccetera eccetera, è pensato appunto per chi fa montaggio video, tutto questo.
Capisci che è una cosa ovviamente un settore di nicchia in un settore di nicchia per cui una cosa è iper verticale che però è parte del mio mondo perché nella mia prima professione mi occupo di produrre video per cui le due cose sono collegate tra loro.
Alla fine quello che io chiedo all'ascoltatore che ha fatto questa domanda, quello che ti chiedo è come mai ti è venuta voglia di programmare, qual è la molla che ti ha spinto e sicuramente parti da vorrei fare una cosa così, vorrei fare qualcosa, ti è venuto in mente un prodotto, un progetto, una qualsiasi cosa potrebbe essere da un'idea semplicissima a una cosa molto complicata.
Se tu dici che cosa è che ti ha fatto partire questa molla ti si può più indirizzare dove è più giusto iniziare probabilmente.
Poi il percorso ognuno fa il suo, i ragazzi che hanno risposto all'intervista e probabilmente anche Valerio ti diranno che l'accademia ti fornisce degli strumenti per imparare, la scuola italiana, tutte le scuole italiane essenzialmente dalle scuole elementari fino all'università non ti dice mai come fare le cose sul lavoro, non te lo dice quasi mai.
Tendenzialmente ti fornisce degli strumenti per aprirti la mente su come imparare a fare delle cose, in realtà la scuola italiana quasi non ti insegna ma ti insegna di imparare, che è una cosa anche interessante, è anche forte, è molto potente, però per certi versi necessita che tu faccia un balzo nella fede ulteriore.
Devo dire che a me l'ingegneria ha insegnato una forma mentis, ho odiato ogni singolo minuto che ho passato in quella facoltà, ve lo giuro, io l'ho odiata, odio ingegneria, quando mai ho iniziato, quando mai ho varcato quella cacchio di soglia, anche per presunzione sono andato dicendo sì, posso farlo.
La realtà è che però l'ingegneria mi ha dato la forma mentis su come affrontare dei problemi, è che è difficile specificare questa cosa, cosa significa la forma mentis, significa che dopo un sacco di lavoro più o meno strutturato, adesso quando devo affrontare un problema ho una capacità, non dico che sono capace, che sono bravo, comunque a oggi sono braccia rubate all'agricoltura,
però mi sento un po' più sicuro su come impostarlo questo problema, su come suddividere i problemi in modo più semplice e soprattutto su come strutturare la struttura adatti, che è la cosa più difficile essenzialmente quando si affronta un problema, capire come organizzare le cose.
Vabbè qui sto andando avanti, mi sto dilungando e sto esagerando, dato questo chiedo scusa per questa risposta troppo lunga e senza tante risposte e approfitto dell'occasione per salutare tutti gli ascoltatori di Valerio e Valerio naturalmente, che è una delle persone più gentili e un gran signore del podcasting italiano, che stimo tantissimo e che spero prima o poi di riuscire a riabbracciare di persona, grazie a tutti voi, un abbraccio e buon ascolto.
Bene, io voglio ringraziare Alex e Sirio per essersi impegnati a contribuire al nostro discorso e spero che questo episodio ti abbia fornito degli spunti interessanti su cui ragionare. Per me è stato assolutamente così e penso che in futuro torneremo anche su questo specifico argomento, quindi grazie a entrambi.
Ora, se tutto è andato secondo i miei piani, questo episodio è uscito il giorno 26, quindi oggi non ti stresso ricordandoti di condividere e supportare il sito e blablabla. Sono sicuro che sono cose che già sai e quindi ti ringrazio per aver ascoltato fin qui e colgo invece l'occasione per augurarti un felice anno nuovo.
Noi ci risentiamo direttamente nel 2022 con nuovi propositi, nuovi episodi, nuovi argomenti e nuovi ragionamenti, ma ricordando sempre che un informatico risolve problemi, a volte anche usando il computer.

